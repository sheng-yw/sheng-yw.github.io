<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博客</title>
  
  
  <link href="https://sheng-yw.github.io/atom.xml" rel="self"/>
  
  <link href="https://sheng-yw.github.io/"/>
  <updated>2022-01-06T03:33:45.976Z</updated>
  <id>https://sheng-yw.github.io/</id>
  
  <author>
    <name>wensheng.yws</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://sheng-yw.github.io/2022/01/06/nginx/"/>
    <id>https://sheng-yw.github.io/2022/01/06/nginx/</id>
    <published>2022-01-06T03:33:11.111Z</published>
    <updated>2022-01-06T03:33:45.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>1、安装<br>  1)、上传tgz压缩包至服务器<br>  2)、tar -zxvf nginx.tgz<br>  3)、执行 ./configure –prefix=自定义目录<br>  4)、make &amp;&amp; make install<br>  5)、cd 自定义目录<br>  6)、启动 ./sbin/nginx<br>  7)、重启 ./sbin/nginx -s reload<br>2、查看ng进程<br>  ps –ef | grep<br>3、查看ng服务<br>  ps -A | grep nginx    </p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>ng文件包括1、全局模块；2、http模块；3、events模块<br>http模块嵌套多个server,配置代理,缓存,日志等<br>server模块配置虚拟主机的相关参数，一个http中可以配置多个server<br>server中location块是处理符合请求规则的资源导向问题，也是我们主要配置的核心模块<br>loaction中匹配规则<br>location = /uri =开头表示精确匹配，只有完全匹配上才能生效<br>lcoation = ^ <del>/uri ^</del> 开头对URL路径进行前缀匹配，并且在正则之前<br>location ~ pattern 　~开头表示区分大小写的正则匹配。<br>location ~* pattern 　~*开头表示不区分大小写的正则匹配。<br>location /uri 不带任何修饰符，也表示前缀匹配，但是在正则匹配之后。<br>location / 　通用匹配，任何未匹配到其它location的请求都会匹配到，相当于switch中的default<br>location 与 root相结合表示的是实际请求的资源会自动拼接location后的uri<br>location 与 alias相结合表示的是实际请求的资源会去alias配置的路径去获取 但是后缀要加”/“</p><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nginx&quot;&gt;&lt;a href=&quot;#Nginx&quot; class=&quot;headerlink&quot; title=&quot;Nginx&quot;&gt;&lt;/a&gt;Nginx&lt;/h1&gt;&lt;p&gt;1、安装&lt;br&gt;  1)、上传tgz压缩包至服务器&lt;br&gt;  2)、tar -zxvf nginx.tgz&lt;br&gt; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://sheng-yw.github.io/2021/12/09/es/"/>
    <id>https://sheng-yw.github.io/2021/12/09/es/</id>
    <published>2021-12-09T06:29:41.187Z</published>
    <updated>2021-12-09T08:09:13.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES是什么"><a href="#ES是什么" class="headerlink" title="ES是什么"></a>ES是什么</h1><h1 id="ES有什么用"><a href="#ES有什么用" class="headerlink" title="ES有什么用"></a>ES有什么用</h1><h1 id="ES怎么存，怎么取"><a href="#ES怎么存，怎么取" class="headerlink" title="ES怎么存，怎么取"></a>ES怎么存，怎么取</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ES是什么&quot;&gt;&lt;a href=&quot;#ES是什么&quot; class=&quot;headerlink&quot; title=&quot;ES是什么&quot;&gt;&lt;/a&gt;ES是什么&lt;/h1&gt;&lt;h1 id=&quot;ES有什么用&quot;&gt;&lt;a href=&quot;#ES有什么用&quot; class=&quot;headerlink&quot; title=&quot;E</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://sheng-yw.github.io/2021/08/26/node/"/>
    <id>https://sheng-yw.github.io/2021/08/26/node/</id>
    <published>2021-08-26T08:39:02.231Z</published>
    <updated>2021-12-29T08:54:42.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="egg框架"><a href="#egg框架" class="headerlink" title="egg框架"></a>egg框架</h1><h2 id="egg之框架统一错误处理"><a href="#egg之框架统一错误处理" class="headerlink" title="egg之框架统一错误处理"></a>egg之框架统一错误处理</h2><p>  config/default.config.js 中配置<br>  <code>config.onerror = &#123;</code><br>  <code>  all: (err, ctx) =&gt; &#123;</code><br>  <code>    ctx.set(&#123;&#39;Content-Type&#39;: &#39;application/json&#39;&#125;);</code><br>  <code>    ctx.status = 200;</code><br>  <code>    ctx.body = JSON.stringfy(&#123;</code><br>  <code>      success: false,</code><br>  <code>      message: err.message</code><br>  <code>    &#125;)</code><br>  <code>  &#125;</code><br>  <code>&#125;</code></p><h2 id="pm2相关"><a href="#pm2相关" class="headerlink" title="pm2相关"></a>pm2相关</h2><p>  pm2 list 查看启动的服务<br>  pm2 stop ip 停止某一个服务<br>  pm2 start pm2.json 在项目目录下 pm2 启动某一个项目<br>  pm2 delete ip 删除某一个服务<br>  pm2 restart ip 重启某个服务<br>  pm2 log ip 查看某一个服务的日志<br>  pm2 启动时指定node版本需要在pm2.json中配置 “interpreter”: “./node_modules/.bin/node”,<br>  或者在执行 pm2 start server.js –interpreter ./node_modules/.bin/node</p><h2 id="avn相关"><a href="#avn相关" class="headerlink" title="avn相关"></a>avn相关</h2><p>  avn 是一个自动切换node版本的管理工具，需要和nvm配合使用 npm i avn avn-nvm -g<br>  需要在项目中配置.node-version文件 内容例如：12.0.0<br>  cd 到当前目录中会自动切换到这个版本的node</p><h2 id="nodeinstall相关"><a href="#nodeinstall相关" class="headerlink" title="nodeinstall相关"></a>nodeinstall相关</h2><p>  nodeinstall 可以使node服务采用node_modules中的node 依赖而不依赖后端<br>  npm i nodeinstall -g<br>  安装完自身依赖以后执行 nodeinstall 10.0.0<br>  查看安装版本 ./node_modules/.bin/node -v</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;egg框架&quot;&gt;&lt;a href=&quot;#egg框架&quot; class=&quot;headerlink&quot; title=&quot;egg框架&quot;&gt;&lt;/a&gt;egg框架&lt;/h1&gt;&lt;h2 id=&quot;egg之框架统一错误处理&quot;&gt;&lt;a href=&quot;#egg之框架统一错误处理&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://sheng-yw.github.io/2021/08/26/phone/"/>
    <id>https://sheng-yw.github.io/2021/08/26/phone/</id>
    <published>2021-08-26T08:30:15.715Z</published>
    <updated>2021-09-06T03:14:06.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移动端知识点"><a href="#移动端知识点" class="headerlink" title="移动端知识点"></a>移动端知识点</h1><h1 id="关于适配"><a href="#关于适配" class="headerlink" title="关于适配"></a>关于适配</h1><p> 常见的适配rem、rm、vw<br> rem是根据设计图纸来设置html标签的font-size的大小，开发时在进行等比例换算成rem<br> qq、uc浏览器对小于12px的字体大小会按照12px来计算，这点需要注意计算出的1rem不要小于12px</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;移动端知识点&quot;&gt;&lt;a href=&quot;#移动端知识点&quot; class=&quot;headerlink&quot; title=&quot;移动端知识点&quot;&gt;&lt;/a&gt;移动端知识点&lt;/h1&gt;&lt;h1 id=&quot;关于适配&quot;&gt;&lt;a href=&quot;#关于适配&quot; class=&quot;headerlink&quot; title=&quot;关</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://sheng-yw.github.io/2021/05/25/webpack/"/>
    <id>https://sheng-yw.github.io/2021/05/25/webpack/</id>
    <published>2021-05-25T02:51:12.272Z</published>
    <updated>2021-08-27T08:36:52.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Webpack构成"><a href="#Webpack构成" class="headerlink" title="Webpack构成"></a>Webpack构成</h1><h1 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h1><h1 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h1><h1 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化"></a>打包优化</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Webpack构成&quot;&gt;&lt;a href=&quot;#Webpack构成&quot; class=&quot;headerlink&quot; title=&quot;Webpack构成&quot;&gt;&lt;/a&gt;Webpack构成&lt;/h1&gt;&lt;h1 id=&quot;loader&quot;&gt;&lt;a href=&quot;#loader&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://sheng-yw.github.io/2021/05/06/react/"/>
    <id>https://sheng-yw.github.io/2021/05/06/react/</id>
    <published>2021-05-06T10:13:12.626Z</published>
    <updated>2021-12-09T06:29:33.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React系列之useState"><a href="#React系列之useState" class="headerlink" title="React系列之useState"></a>React系列之useState</h1><p>  基本用法<br>  <code>const [state, setState] = useState(initialState);</code><br>  当然也可以写成<br>  <code>const state = useState(initialState)</code><br>  state为数组 state[0]为状态值 state[1]为更新状态的函数<br>  我们知道useState跟新状态时为异步更新，setState又没有跟之前版本提供回调，当想要同步获取最新值时可以这样<br>  <code>useEffect(() =&gt; &#123;</code><br>    <code>TODO 处理你的逻辑</code><br>  <code>&#125;, [state])</code><br>  但是这个方法会在初始化时执行<br>  <code>setState(() =&gt; &#123;</code><br>    <code>TODO 处理你的逻辑</code><br>    <code>return newState</code><br>  <code>&#125;)</code><br>  newState为想要改变的最新值，在这个回调中处理逻辑</p><p>  多次setState时React会自动合并成一次setState，但是有些情况下是不会的，这时就需要使用<br>  ReactDOM.unstable_batchedUpdates 这个api来手动处理多次合并一次</p><h1 id="React系列中useEffect"><a href="#React系列中useEffect" class="headerlink" title="React系列中useEffect"></a>React系列中useEffect</h1><p>  useEffect是可以让你在函数组件中执行副作用操作(相当于类组件中生命周期函数)<br>  它可以看作是三个生命周期函数的组合<br>  1、componentDidMount<br>    <code>useEffect(() =&gt; &#123;&#125;, [])</code><br>    组件生命周期内执行一次<br>  2、componentDidUpdate<br>    <code>useEffect(() =&gt; &#123;&#125;, [state])</code><br>    此写法也会在初始化时执行，state变化时再次执行<br>  3、componentWillUnMount<br>    <code>useEffect(() =&gt; &#123;</code><br>    <code>  return () =&gt; &#123;</code><br>    <code>    //TODO 组件销毁前执行</code><br>    <code>  &#125;</code><br>    <code>&#125;, [])</code></p><h1 id="useEffect有哪些注意点"><a href="#useEffect有哪些注意点" class="headerlink" title="useEffect有哪些注意点"></a>useEffect有哪些注意点</h1><p>  1、假如说useEffect监听了多个state,同事更新多个state情况会导致useEffect中函数执行多次，这样就需要特别处理多个state合并一个或者在里面进行判断(业务场景复杂多样，具体还是要在设计之初就考虑进去)<br>  2、禁止在条件语句中使用<br>    <code>if (name !== &#39;xx&#39;) &#123;</code><br>    <code>  useEffect(() =&gt; &#123;&#125;, [])</code><br>    <code>&#125;</code></p><h1 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h1><p>  在方法函数，由于不能使用shouldComponentUpdate处理性能问题，react hooks新增了useMemo<br>  用来缓存数据，当渲染的数据需要根据state、props经过特定计算而来的时候可以使用useMemo函数缓存这个数据、避免重复调用计算函数浪费性能<br>  <code>const x = useMemo(() =&gt; &#123;</code><br>  <code>//TODO</code><br>  <code>&#125;, [xx])</code><br>  如果useMemo(fn, arr)第二个参数发生变化，则去执行fn 否则只会执行一次，[]也是执行一次</p><h1 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h1><p>  用来监听变量缓存或生成一个函数，fn通常当作props进行传递用于子组件进行监听！<br>  <code>const fn = useCallback(() =&gt; &#123;</code><br>  <code>//TODO</code><br>  <code>&#125;, [xx])</code><br>  ``</p><h1 id="useContent"><a href="#useContent" class="headerlink" title="useContent"></a>useContent</h1><p>  全局上下文配合usereducer可以做到全局的状态管理 替代mobx、redux<br>  <code>function createContainer(useHook)&#123;</code><br>  <code>  const Context = react.createContext(null)</code><br>  <code>  const Provider = props =&gt; &#123;</code><br>  <code>    const value = useHook(props.initialValue)</code><br>  <code>    retrun (</code><br>  <code>      &lt;Context.Provider value=&#123;value&#125;&gt;</code><br>  <code>        &#123;props.children&#125;</code><br>  <code>      &lt;/Context.Provider&gt;</code><br>  <code>    )</code><br>  <code>  &#125;</code><br>  <code>  const useContainer = () =&gt; &#123;</code><br>  <code>    const value = React.useContext(Context)</code><br>  <code>    return value</code><br>  <code>  &#125;</code><br>  <code>  return &#123;</code><br>  <code>    Provider,</code><br>  <code>    useContainer</code><br>  <code>  &#125;</code></p><p>  <code>const fn = createContainer(() =&gt; &#123;</code><br>  <code>  const reducer = (state, action) =&gt; &#123;</code><br>  <code>    switch(action.type) &#123;</code><br>  <code>      case &#39;xx&#39;:</code><br>  <code>        return &#123;...state, xx: action.xx&#125;</code><br>  <code>        break;</code><br>  <code>    &#125;</code><br>  <code> &#125;)</code><br>  <code>  const initState = &#123;</code><br>  <code>    xx: xx</code><br>  <code>  &#125;</code><br>  <code>  const [state, dispatch] = useReducer(reducer, initState)</code><br>  <code>  return &#123;</code><br>  <code>    state, dispatch</code><br>  <code>  &#125;</code><br>  最外围组件使用<br>  <code>&lt;Logic.Provider&gt;xxxx&lt;/Logic.Provider&gt;</code><br>  组件内使用 先引入<br>  <code>const &#123; state, dispatch &#125; = Logic.useContainer()</code></p><h1 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h1><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h1 id="react-生命周期"><a href="#react-生命周期" class="headerlink" title="react 生命周期"></a>react 生命周期</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;React系列之useState&quot;&gt;&lt;a href=&quot;#React系列之useState&quot; class=&quot;headerlink&quot; title=&quot;React系列之useState&quot;&gt;&lt;/a&gt;React系列之useState&lt;/h1&gt;&lt;p&gt;  基本用法&lt;br&gt;  &lt;c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://sheng-yw.github.io/2021/04/22/day-question/"/>
    <id>https://sheng-yw.github.io/2021/04/22/day-question/</id>
    <published>2021-04-22T05:59:50.528Z</published>
    <updated>2022-02-07T01:58:17.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h1><h2 id="bind、call、apply三者有什么异同"><a href="#bind、call、apply三者有什么异同" class="headerlink" title="bind、call、apply三者有什么异同"></a>bind、call、apply三者有什么异同</h2><p>  1、三者都是改变传入函数的this指向<br>  2、call、apply都是立即执行函数改变本次函数调用的this指向<br>  3、call方法传参是参数列表形式、apply方法传参是数组形式<br>  4、bind方法是返回一个永久改变this的新函数，传参方式是参数列表形式</p><h2 id="看如下代码写出a是什么及打印结果"><a href="#看如下代码写出a是什么及打印结果" class="headerlink" title="看如下代码写出a是什么及打印结果"></a>看如下代码写出a是什么及打印结果</h2><p>  <code>if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)&#123;</code><br>  <code>  console.log(a)</code><br>  <code>&#125;</code><br>  答案valueOf版本<br>  <code>const a = &#123;</code><br>  <code>  value: 1,</code><br>  <code>&#125;</code><br>  <code>a.__proto__.valueOf = function () &#123;</code><br>  <code>  return a.value++</code><br>  <code>&#125;</code><br>  <code>a = &#123;value: 4&#125;</code><br>  答案tostring版本<br>  <code>const a = [3, 2, 1]</code><br>  <code>a.__proto_.toString = function () &#123;</code><br>  <code>  return a.pop()</code><br>  <code>&#125;</code><br>  <code> a = []</code><br>  使用了js中自动转换调用valueOf/toString</p><h2 id="React生命周期及其作用"><a href="#React生命周期及其作用" class="headerlink" title="React生命周期及其作用"></a>React生命周期及其作用</h2><p>  constructor:<br>    1、用于初始化内部状态，很少使用<br>    2、唯一一个可以直接修改state的地方</p><h2 id="开发中常用api"><a href="#开发中常用api" class="headerlink" title="开发中常用api"></a>开发中常用api</h2><p>Array篇<br><code>[].map(it =&gt; return it) //返回一个新数组</code><br><code>[].indexOf(it) //返回的是当前元素的下标 没有则返回-1</code><br><code>[].includes(it) //判断当前元素是否在数组内</code><br><code>[].concat([]) //拼接两个数组 返回拼接后新数组</code><br><code>[].splice(index, length, item) //获取从index开始有length数的数组 item有值则会添加到原数组中</code><br><code>[].sort((a, b) =&gt; a-b) //从小到大 b-a从大到小</code><br><code>[].reduce((pre, next) =&gt; pre+next) //数组求和</code><br><code>[].find(it =&gt; it) //从数组中查找某一个符合条件的元素 找不到为undefined</code><br><code>[].filter(it =&gt; it) //从数组中筛选符合条件的元素 找不到为[]</code><br><code>[].forEach(it =&gt; console.log(it)) //遍历这个数组</code><br><code>[].push(it) //向数组尾部添加一个元素</code><br><code>[].pop() //尾部弹出一个元素 返回弹出的元素 原数组改变</code><br><code>[].shift() //数组头部弹出一个元素 返回弹出的元素 原数组改变</code><br><code>[].unshift //数组头部添加一个元素 原数组改变</code><br><code>[1,[2,[3]]].flat(2) =&gt; [1,2,3] //打平一个多维数组 参数是层级 返回新数组原数组不变</code><br>Object篇<br><code>Object.prototype.toString(arg) //可用于判断元素是什么类型</code><br><code>Object.keys(arg) //返回这个对象所有属性的数组</code><br><code>Object.values(arg) //返回这个对象所有属性值的数组</code><br><code>Object.defineProperties(obj, props) //方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象 Vue3之前最重要的一个api</code><br>``</p><h2 id="检测类型的方法"><a href="#检测类型的方法" class="headerlink" title="检测类型的方法"></a>检测类型的方法</h2><p>typeof 使用来判断检测对象的属性 但是typeof null 返回的是object、并非是bug只是js设计如此、区分数组跟对象时不能正确判断<br>instanceof 用来检测左侧引用的__proto__是否在右侧对象的Ptototype上，通过原型链查找故这个方法不能判断基本数据类型<br>Object.prototype.toString.call(param) 返回具体是什么类型，适用所有类型<br>通过构造函数指向判断<br>  <code>let a = 123</code><br>  <code>a.constructor === Number // true</code></p><h2 id="hash路由跟history路由的区别"><a href="#hash路由跟history路由的区别" class="headerlink" title="hash路由跟history路由的区别"></a>hash路由跟history路由的区别</h2><p>1、直观来看hash就是url中带#号history不带<br>2、hash监听url中hash值的变化(#号后面的内容),不向服务器发送请求就可以改变页面展示<br>   history则是监听url整体变化，回去请求服务端需要两端共同支持<br>3、hash是支持低版本浏览器的，#号后面值的变化都会触发window.onhashchange,不论浏览器的<br>  前进还是后退都会触发<br>  history则是基于Html5新增API产生的</p><h2 id="px、rem、em有什么区别"><a href="#px、rem、em有什么区别" class="headerlink" title="px、rem、em有什么区别"></a>px、rem、em有什么区别</h2><p>px代表像素，相对长度单位，像素px是相对于显示器屏幕分辨率而言的，1px就是屏幕上的一个小方格点<br>rem相对单位，相较于页面根元素大小而定，在做适配时常用，只需要改变跟元素大小就能调整所有字体大小<br>em相对单位，相对于最近父元素大小而言，如未设置则取浏览器默认大小</p><h2 id="关于使用React-lazy的问题"><a href="#关于使用React-lazy的问题" class="headerlink" title="关于使用React.lazy的问题"></a>关于使用React.lazy的问题</h2><p>  使用React.lazy进行加载组件不做处理会报错A React component suspended while rendering, but no fallback UI was specified.<br>  错误原因是用lazy 之后, 存在加载中的空档, react 不知道在这个空当中该显示什么, 所以需要我们指定<br>  解决办法<br>    使用 Suspense 组件包裹路由组件、进行提示加载的空档做什么<br>    <code>&lt;Suspense</code><br>    <code> fallback=&#123;</code><br>    <code>   &lt;Spin spinning&gt;</code><br>    <code>      &lt;div style=&#123;&#123; width: '100%', height: '100vh' &#125;&#125; /&gt;</code><br>    <code>   &lt;/Spin&gt;</code><br>    <code> &#125;</code><br>    <code>&gt;</code><br>    <code>  &lt;Router&gt;</code><br>    <code>    &lt;Switch&gt;</code><br>    <code>      &lt;Route path=&quot;/create&quot; component=&#123;Create&#125;/&gt;</code><br>    <code>    &lt;/Switch&gt;</code><br>    <code>  &lt;/Router&gt;</code><br>    <code>&lt;/Suspense&gt;</code></p><h2 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h2><p>  400 请求无效<br>  403 禁止访问 无权限<br>  404 资源找不到、路径错误或者没有要请求的资源<br>  405 资源被禁止<br>  408 资源超时<br>  200 请求ok<br>  502 请求方法不匹配<br>  500 服务器出错</p><h2 id="webpack优化手段"><a href="#webpack优化手段" class="headerlink" title="webpack优化手段"></a>webpack优化手段</h2><p>  1、优化loader查找范围 例如Babel只转换src下的文件<br>  2、cache-loader缓存loader处理结果<br>  3、多线程处理打包<br>  4、删除无用css    purgecss-webpack-plugin 配合 mini-css-extract-plugin使用<br>  5、以CDN方式加载资源   add-asset-html-cdn-webpack-plugin插件<br>  6、对图片进行压缩优化  image-webpack-loader<br>  7、通过speed-measure-webpack-plugin插件查看哪个模块打包费时<br>  8、</p><h2 id="React和ReactDOM的区别"><a href="#React和ReactDOM的区别" class="headerlink" title="React和ReactDOM的区别"></a>React和ReactDOM的区别</h2><p>  React是React库的入口，可以使用 jsx语法、组件、ref、hooks等属性或api<br>  ReactDOM只负责和浏览器或DOM操作相关  </p><h2 id="redux与mobx的区别"><a href="#redux与mobx的区别" class="headerlink" title="redux与mobx的区别"></a>redux与mobx的区别</h2><p>  redux将数据保存在单一store中mobx分散存放的</p><h2 id="Promise中api"><a href="#Promise中api" class="headerlink" title="Promise中api"></a>Promise中api</h2><p>  all 顺序执行 有一个失败都为失败<br>  allSettled 顺序执行 可以获取每一个的状态<br>  race 获取第一个的状态</p><h2 id="浅谈webpack打包流程"><a href="#浅谈webpack打包流程" class="headerlink" title="浅谈webpack打包流程"></a>浅谈webpack打包流程</h2><h2 id="js监听dom变化"><a href="#js监听dom变化" class="headerlink" title="js监听dom变化"></a>js监听dom变化</h2><p>1、获取要监听的dom<br>const dom = document.querySelector(‘#id’)<br>2、创建监听对象 MutationObserver<br>const hanldChange = function (dom, observer) {<br>  console.log(dom, observer)<br>}<br>const mutationObserver = new MutationObserver(hanldChange)<br>3、定义监听属性、开启监听<br>const options = {<br>  attributes: true<br>}<br>mutationObserver.observer(dom, options)<br>4、停止监听<br>mutationObserver.disconnect()<br>5、清除变动记录并返回记录值<br>const changes = mutationObserver.takeRecords()</p><h2 id="package-json中版本～-含义"><a href="#package-json中版本～-含义" class="headerlink" title="package.json中版本～ ^含义"></a>package.json中版本～ ^含义</h2><p>～表示例如1.2.2下载最新的1.2.x的最新包但不会低于1.2.2<br>^表示 例如1.2.2 下载1.x.x 的最新包 不会低于1.2.2</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;每日一题&quot;&gt;&lt;a href=&quot;#每日一题&quot; class=&quot;headerlink&quot; title=&quot;每日一题&quot;&gt;&lt;/a&gt;每日一题&lt;/h1&gt;&lt;h2 id=&quot;bind、call、apply三者有什么异同&quot;&gt;&lt;a href=&quot;#bind、call、apply三者有什么异同&quot;</summary>
      
    
    
    
    
  </entry>
  
</feed>
