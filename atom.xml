<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博客</title>
  
  
  <link href="https://sheng-yw.github.io/atom.xml" rel="self"/>
  
  <link href="https://sheng-yw.github.io/"/>
  <updated>2021-08-26T08:39:02.231Z</updated>
  <id>https://sheng-yw.github.io/</id>
  
  <author>
    <name>wensheng.yws</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://sheng-yw.github.io/2021/08/26/node/"/>
    <id>https://sheng-yw.github.io/2021/08/26/node/</id>
    <published>2021-08-26T08:39:02.231Z</published>
    <updated>2021-08-26T08:39:02.231Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://sheng-yw.github.io/2021/08/26/nginx/"/>
    <id>https://sheng-yw.github.io/2021/08/26/nginx/</id>
    <published>2021-08-26T08:38:43.393Z</published>
    <updated>2021-08-26T08:38:43.393Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://sheng-yw.github.io/2021/08/26/phone/"/>
    <id>https://sheng-yw.github.io/2021/08/26/phone/</id>
    <published>2021-08-26T08:30:15.715Z</published>
    <updated>2021-08-26T08:30:22.985Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://sheng-yw.github.io/2021/05/25/webpack/"/>
    <id>https://sheng-yw.github.io/2021/05/25/webpack/</id>
    <published>2021-05-25T02:51:12.272Z</published>
    <updated>2021-08-26T08:38:08.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React系列中useEffect"><a href="#React系列中useEffect" class="headerlink" title="React系列中useEffect"></a>React系列中useEffect</h1><h1 id="什么是useEffect"><a href="#什么是useEffect" class="headerlink" title="什么是useEffect"></a>什么是useEffect</h1><p>  useEffect是可以让你在函数组件中执行副作用操作(相当于类组件中生命周期函数)<br>  它可以看作是三个生命周期函数的组合<br>  1、componentDidMount<br>    <code>useEffect(() =&gt; &#123;&#125;, [])</code><br>    组件生命周期内执行一次<br>  2、componentDidUpdate<br>    <code>useEffect(() =&gt; &#123;&#125;, [state])</code><br>    此写法也会在初始化时执行，state变化时再次执行<br>  3、componentWillUnMount<br>    <code>useEffect(() =&gt; &#123;</code><br>    <code>  return () =&gt; &#123;</code><br>    <code>    //TODO 组件销毁前执行</code><br>    <code>  &#125;</code><br>    <code>&#125;, [])</code></p><h1 id="useEffect有哪些注意点"><a href="#useEffect有哪些注意点" class="headerlink" title="useEffect有哪些注意点"></a>useEffect有哪些注意点</h1><p>  1、假如说useEffect监听了多个state,同事更新多个state情况会导致useEffect中函数执行多次，这样就需要特别处理多个state合并一个或者在里面进行判断(业务场景复杂多样，具体还是要在设计之初就考虑进去)<br>  2、禁止在条件语句中使用<br>    <code>if (name !== &#39;xx&#39;) &#123;</code><br>    <code>  useEffect(() =&gt; &#123;&#125;, [])</code><br>    <code>&#125;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;React系列中useEffect&quot;&gt;&lt;a href=&quot;#React系列中useEffect&quot; class=&quot;headerlink&quot; title=&quot;React系列中useEffect&quot;&gt;&lt;/a&gt;React系列中useEffect&lt;/h1&gt;&lt;h1 id=&quot;什么是us</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://sheng-yw.github.io/2021/05/06/react/"/>
    <id>https://sheng-yw.github.io/2021/05/06/react/</id>
    <published>2021-05-06T10:13:12.626Z</published>
    <updated>2021-08-26T08:37:57.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React系列之useState"><a href="#React系列之useState" class="headerlink" title="React系列之useState"></a>React系列之useState</h1><p>  基本用法<br>  <code>const [state, setState] = useState(initialState);</code><br>  当然也可以写成<br>  <code>const state = useState(initialState)</code><br>  state为数组 state[0]为状态值 state[1]为更新状态的函数<br>  我们知道useState跟新状态时为异步更新，setState又没有跟之前版本提供回调，当想要同步获取最新值时可以这样<br>  <code>useEffect(() =&gt; &#123;</code><br>    <code>TODO 处理你的逻辑</code><br>  <code>&#125;, [state])</code><br>  但是这个方法会在初始化时执行<br>  <code>setState(() =&gt; &#123;</code><br>    <code>TODO 处理你的逻辑</code><br>    <code>return newState</code><br>  <code>&#125;)</code><br>  newState为想要改变的最新值，在这个回调中处理逻辑</p><h2 id="关于优化"><a href="#关于优化" class="headerlink" title="关于优化"></a>关于优化</h2><p>  setState为异步更新调用一次渲染一次，所以在一个方法内调用多个不同的setState时会导致许多不必要的性能消耗！解决办法我总结了一下两点<br>  1、把多个state合并成一个state<br>  2、使用React中自带api解决<br>    <code>ReactDOM.unstable_batchedUpdates(() =&gt; &#123;</code><br>      <code>setState1(xxx)</code><br>      <code>setState2(xxx)</code><br>    <code>&#125;)</code></p><h1 id="React系列中useEffect"><a href="#React系列中useEffect" class="headerlink" title="React系列中useEffect"></a>React系列中useEffect</h1><p>  useEffect是可以让你在函数组件中执行副作用操作(相当于类组件中生命周期函数)<br>  它可以看作是三个生命周期函数的组合<br>  1、componentDidMount<br>    <code>useEffect(() =&gt; &#123;&#125;, [])</code><br>    组件生命周期内执行一次<br>  2、componentDidUpdate<br>    <code>useEffect(() =&gt; &#123;&#125;, [state])</code><br>    此写法也会在初始化时执行，state变化时再次执行<br>  3、componentWillUnMount<br>    <code>useEffect(() =&gt; &#123;</code><br>    <code>  return () =&gt; &#123;</code><br>    <code>    //TODO 组件销毁前执行</code><br>    <code>  &#125;</code><br>    <code>&#125;, [])</code></p><h1 id="useEffect有哪些注意点"><a href="#useEffect有哪些注意点" class="headerlink" title="useEffect有哪些注意点"></a>useEffect有哪些注意点</h1><p>  1、假如说useEffect监听了多个state,同事更新多个state情况会导致useEffect中函数执行多次，这样就需要特别处理多个state合并一个或者在里面进行判断(业务场景复杂多样，具体还是要在设计之初就考虑进去)<br>  2、禁止在条件语句中使用<br>    <code>if (name !== &#39;xx&#39;) &#123;</code><br>    <code>  useEffect(() =&gt; &#123;&#125;, [])</code><br>    <code>&#125;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;React系列之useState&quot;&gt;&lt;a href=&quot;#React系列之useState&quot; class=&quot;headerlink&quot; title=&quot;React系列之useState&quot;&gt;&lt;/a&gt;React系列之useState&lt;/h1&gt;&lt;p&gt;  基本用法&lt;br&gt;  &lt;c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://sheng-yw.github.io/2021/04/22/day-question/"/>
    <id>https://sheng-yw.github.io/2021/04/22/day-question/</id>
    <published>2021-04-22T05:59:50.528Z</published>
    <updated>2021-08-26T08:38:32.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h1><h2 id="bind、call、apply三者有什么异同"><a href="#bind、call、apply三者有什么异同" class="headerlink" title="bind、call、apply三者有什么异同"></a>bind、call、apply三者有什么异同</h2><p>  1、三者都是改变传入函数的this指向<br>  2、call、apply都是立即执行函数改变本次函数调用的this指向<br>  3、call方法传参是参数列表形式、apply方法传参是数组形式<br>  4、bind方法是返回一个永久改变this的新函数，传参方式是参数列表形式</p><h2 id="看如下代码写出a是什么及打印结果"><a href="#看如下代码写出a是什么及打印结果" class="headerlink" title="看如下代码写出a是什么及打印结果"></a>看如下代码写出a是什么及打印结果</h2><p>  <code>if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)&#123;</code><br>  <code>  console.log(a)</code><br>  <code>&#125;</code><br>  答案valueOf版本<br>  <code>const a = &#123;</code><br>  <code>  value: 1,</code><br>  <code>&#125;</code><br>  <code>a.__proto__.valueOf = function () &#123;</code><br>  <code>  return a.value++</code><br>  <code>&#125;</code><br>  <code>a = &#123;value: 4&#125;</code><br>  答案tostring版本<br>  <code>const a = [3, 2, 1]</code><br>  <code>a.__proto_.toString = function () &#123;</code><br>  <code>  return a.pop()</code><br>  <code>&#125;</code><br>  <code> a = []</code><br>  使用了js中自动转换调用valueOf/toString</p><h2 id="React生命周期及其作用"><a href="#React生命周期及其作用" class="headerlink" title="React生命周期及其作用"></a>React生命周期及其作用</h2><p>  constructor:<br>    1、用于初始化内部状态，很少使用<br>    2、唯一一个可以直接修改state的地方</p><h2 id="开发中常用api"><a href="#开发中常用api" class="headerlink" title="开发中常用api"></a>开发中常用api</h2><p>Array篇<br><code>[].map(it =&gt; return it) //返回一个新数组</code><br><code>[].indexOf(it) //返回的是当前元素的下标 没有则返回-1</code><br><code>[].includes(it) //判断当前元素是否在数组内</code><br><code>[].concat([]) //拼接两个数组 返回拼接后新数组</code><br><code>[].splice(index, length, item) //获取从index开始有length数的数组 item有值则会添加到原数组中</code><br><code>[].sort((a, b) =&gt; a-b) //从小到大 b-a从大到小</code><br><code>[].reduce((pre, next) =&gt; pre+next) //数组求和</code><br><code>[].find(it =&gt; it) //从数组中查找某一个符合条件的元素 找不到为undefined</code><br><code>[].filter(it =&gt; it) //从数组中筛选符合条件的元素 找不到为[]</code><br><code>[].forEach(it =&gt; console.log(it)) //遍历这个数组</code><br><code>[].push(it) //向数组尾部添加一个元素</code><br><code>[].pop() //尾部弹出一个元素 返回弹出的元素 原数组改变</code><br><code>[].shift() //数组头部弹出一个元素 返回弹出的元素 原数组改变</code><br><code>[].unshift //数组头部添加一个元素 原数组改变</code><br><code>[1,[2,[3]]].flat(2) =&gt; [1,2,3] //打平一个多维数组 参数是层级 返回新数组原数组不变</code><br>Object篇<br><code>Object.prototype.toString(arg) //可用于判断元素是什么类型</code><br><code>Object.keys(arg) //返回这个对象所有属性的数组</code><br><code>Object.values(arg) //返回这个对象所有属性值的数组</code><br><code>Object.defineProperties(obj, props) //方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象 Vue3之前最重要的一个api</code><br>``</p><h2 id="检测类型的方法"><a href="#检测类型的方法" class="headerlink" title="检测类型的方法"></a>检测类型的方法</h2><p>typeof 使用来判断检测对象的属性 但是typeof null 返回的是object、并非是bug只是js设计如此、区分数组跟对象时不能正确判断<br>instanceof 用来检测左侧引用的__proto__是否在右侧对象的Ptototype上，通过原型链查找故这个方法不能判断基本数据类型<br>Object.prototype.toString.call(param) 返回具体是什么类型，适用所有类型<br>通过构造函数指向判断<br>  <code>let a = 123</code><br>  <code>a.constructor === Number // true</code></p><h2 id="hash路由跟history路由的区别"><a href="#hash路由跟history路由的区别" class="headerlink" title="hash路由跟history路由的区别"></a>hash路由跟history路由的区别</h2><p>1、直观来看hash就是url中带#号history不带<br>2、hash监听url中hash值的变化(#号后面的内容),不向服务器发送请求就可以改变页面展示<br>   history则是监听url整体变化，回去请求服务端需要两端共同支持<br>3、hash是支持低版本浏览器的，#号后面值的变化都会触发window.onhashchange,不论浏览器的<br>  前进还是后退都会触发<br>  history则是基于Html5新增API产生的</p><h2 id="px、rem、em有什么区别"><a href="#px、rem、em有什么区别" class="headerlink" title="px、rem、em有什么区别"></a>px、rem、em有什么区别</h2><p>px代表像素，相对长度单位，像素px是相对于显示器屏幕分辨率而言的，1px就是屏幕上的一个小方格点<br>rem相对单位，相较于页面根元素大小而定，在做适配时常用，只需要改变跟元素大小就能调整所有字体大小<br>em相对单位，相对于最近父元素大小而言，如未设置则取浏览器默认大小</p><h2 id="关于使用React-lazy的问题"><a href="#关于使用React-lazy的问题" class="headerlink" title="关于使用React.lazy的问题"></a>关于使用React.lazy的问题</h2><p>  使用React.lazy进行加载组件不做处理会报错A React component suspended while rendering, but no fallback UI was specified.<br>  错误原因是用lazy 之后, 存在加载中的空档, react 不知道在这个空当中该显示什么, 所以需要我们指定<br>  解决办法<br>    使用 Suspense 组件包裹路由组件、进行提示加载的空档做什么<br>    <code>&lt;Suspense</code><br>    <code> fallback=&#123;</code><br>    <code>   &lt;Spin spinning&gt;</code><br>    <code>      &lt;div style=&#123;&#123; width: '100%', height: '100vh' &#125;&#125; /&gt;</code><br>    <code>   &lt;/Spin&gt;</code><br>    <code> &#125;</code><br>    <code>&gt;</code><br>    <code>  &lt;Router&gt;</code><br>    <code>    &lt;Switch&gt;</code><br>    <code>      &lt;Route path=&quot;/create&quot; component=&#123;Create&#125;/&gt;</code><br>    <code>    &lt;/Switch&gt;</code><br>    <code>  &lt;/Router&gt;</code><br>    <code>&lt;/Suspense&gt;</code></p><h2 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h2><p>  400 请求无效<br>  403 禁止访问 无权限<br>  404 资源找不到、路径错误或者没有要请求的资源<br>  405 资源被禁止<br>  408 资源超时<br>  200 请求ok<br>  502 请求方法不匹配<br>  500 服务器出错</p><h2 id="webpack优化手段"><a href="#webpack优化手段" class="headerlink" title="webpack优化手段"></a>webpack优化手段</h2><p>  1、优化loader查找范围 例如Babel只转换src下的文件<br>  2、cache-loader缓存loader处理结果<br>  3、多线程处理打包<br>  4、删除无用css    purgecss-webpack-plugin 配合 mini-css-extract-plugin使用<br>  5、以CDN方式加载资源   add-asset-html-cdn-webpack-plugin插件<br>  6、对图片进行压缩优化  image-webpack-loader<br>  7、通过speed-measure-webpack-plugin插件查看哪个模块打包费时<br>  8、</p><h2 id="React和ReactDOM的区别"><a href="#React和ReactDOM的区别" class="headerlink" title="React和ReactDOM的区别"></a>React和ReactDOM的区别</h2><p>  React是React库的入口，可以使用 jsx语法、组件、ref、hooks等属性或api<br>  ReactDOM只负责和浏览器或DOM操作相关  </p><h2 id="redux与mobx的区别"><a href="#redux与mobx的区别" class="headerlink" title="redux与mobx的区别"></a>redux与mobx的区别</h2><p>  redux将数据保存在单一store中mobx分散存放的</p><h2 id="Promise中api"><a href="#Promise中api" class="headerlink" title="Promise中api"></a>Promise中api</h2><p>  all 顺序执行 又一个失败都为失败<br>  allSettled 顺序执行 可以获取每一个的状态<br>  race 获取第一个的状态</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;每日一题&quot;&gt;&lt;a href=&quot;#每日一题&quot; class=&quot;headerlink&quot; title=&quot;每日一题&quot;&gt;&lt;/a&gt;每日一题&lt;/h1&gt;&lt;h2 id=&quot;bind、call、apply三者有什么异同&quot;&gt;&lt;a href=&quot;#bind、call、apply三者有什么异同&quot;</summary>
      
    
    
    
    
  </entry>
  
</feed>
